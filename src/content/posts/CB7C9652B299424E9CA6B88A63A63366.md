---
title: No Title
pubDate: 2025-04-19T19:10:46.000Z
updatedDate: 2025-04-20T07:47:37.000Z
tags:
  - 生成AI
  - cursor
  - copilot
  - coding
  - claude
  - '3.7'
  - sonnet
isDraft: false
description: >-
  ChatGPT・Claude・Copilot・Geminiなど主要AIの「得意分野」と「苦手分野」を徹底分析。 特に進化著しいClaude 3.7
  Sonnetは、深い推論や透明性・安全性で大規模開発にも強みアリ。苦手を理解しないと逆に効率が下がります。AIごとのキャラクターや使い分け、プロンプト設計のコツまで、現場で本当に役立つノウハウをまとめました。
  「AIを使いこなす開発者」になるための必読ガイドです！
category: Technology
heroImage: ./5d552045136c83696b0d9238f134e25ecae83a0fc65d8d0a05161730ddf20864x1200.png
---

![弱みがある生成AIを使いこなせ](https://object-storage.tyo2.conoha.io/v1/nc_.../blog-astro-assets/5d552045136c83696b0d9238f134e25ecae83a0fc65d8d0a05161730ddf20864x1200.png){.img-fluid}

# 生成AIによるコーディング支援の特性分析：得意・苦手・そして使いこなし方

## はじめに

生成AI（ChatGPT、Cursor、Claude、Copilot、Geminiなど）の登場により、ソフトウェア開発は急速に変化しています。本稿では、こうした生成AIが「どのような作業を得意とし、何が苦手なのか」を構造的に分析し、その理由や対処法、今後の進化、そしてツール・モデルの特性を活かした実践的な使いこなし方までを体系的にまとめます。AIは日進月歩なので今日現在[2025-04-20]のスナップショットです。

生成AIは同じ質問でも毎度異なるコードを生成し再現性が悪いです。そのため本記事は傾向としてまとめました。どなたかのお役に立てたら嬉しいです。

---

## 1. 得意な領域とその理由

### 1.1 新規コードの生成

- 統計的学習により、一般的な構文や設計パターンの出力を得意としています。

- 自然言語からコードへの変換に最適化されています。

- 白紙状態であれば、依存関係も自己完結できます。

### 1.2 追加・拡張

- Transformerモデルによる「続きを予測する」能力に優れています。

- 既存コードへの小規模な追加や条件分岐などに対応しやすいです。

### 1.3 テキスト変換・置換

- フォーマット変換や構文の書き換えを得意とします。

- Markdown、JSON、HTML、SQLなど、複数形式に対応可能です。

---

## 2. 苦手な領域とその理由

### 2.0 生成AIの苦手を理解することの重要性

生成AIの苦手を理解せずに使用すると、以下のような問題が発生し、むしろ開発効率が低下する可能性があります：

- **手戻りの増加**

  - AIの出力をそのまま信用して実装→後から大規模な修正が必要になる

  - 本来人間が確認すべき設計判断をAIに任せてしまい、手戻りが発生

- **デバッグ時間の増大**

  - AIが生成した不完全なコードの問題箇所を特定するのに時間がかかる

  - エラーの原因究明が困難になり、解決までの工数が増える

- **技術的負債の蓄積**

  - AIの出力を理解せずに統合することで、保守性の低いコードが増える

  - 将来的なリファクタリングコストが膨大になるリスク

- **チーム開発への悪影響**

  - コードの意図が不明確になり、他のメンバーの理解・修正が困難に

  - プロジェクト全体の一貫性が失われる可能性

そのため、AIの特性を正しく理解し、人間が主体的に判断・設計することが重要です。

### 2.1 メンテナンス（修正・改変）

- グローバルな整合性の保持を苦手とします。これは、AIが一度に処理できるコンテキストの制限や、コードベース全体の依存関係を完全に理解できないことが原因です。

- 修正に伴う意図や副作用を読み取る力が弱く、ステートレスな構造ゆえに長期的な文脈の保持が困難です。これは、AIが過去の会話や変更履歴を保持できず、各リクエストを独立して処理するためです。


### 2.2 移動・再配置

- コード構造の把握に乏しく、依存関係の再構成を誤る傾向があります。これは、AIがコードベース全体を一度に分析できず、局所的な変更に注目しがちなためです。

- AST（抽象構文木）的な理解を持たないため、整合的な移動を難しく感じます。これは、AIが単なるテキストとしてコードを処理し、プログラミング言語の文法構造を完全には理解できないことが原因です。

### 2.3 実行時エラーやブラウザ連携

- 実行環境とリアルタイムで接続できないため、外部ログやスタックトレースの取得ができません。これは、AIがテキストベースのインターフェースを通じてのみ動作し、実行環境との直接的な相互作用ができない仕組みに起因します。

- デバッグ情報の文脈理解が限定的です。エラーメッセージやスタックトレースを提供されても、実行時の状態や環境変数、ブラウザの状態などの動的な情報が得られないため、正確な問題診断が困難です。

### 2.4 テストデータ・テストコード生成

- 仕様に基づいた網羅的なテスト設計は不得意です。これは、AIが暗黙的な要件や業務ロジックの意図を完全には理解できないためです。

- 境界値や異常系など、テスト観点のカバーには人間の介在が必要です。これは、AIがエッジケースや例外的なシナリオを自発的に想定することが難しく、実際のユースケースに基づいた網羅的なテストケースの設計には限界があるためです。

- テストの優先順位付けや重要度の判断が困難です。これは、AIがビジネス要件やリスク分析の文脈を十分に理解できないことに起因します。

---

## 3. 苦手の要因を体系化

| 苦手な領域           | 主なAI側の限界                   | 備考                                       |
| -------------------- | -------------------------------- | ------------------------------------------ |
| メンテナンス・修正   | 状態の非保持、整合性の維持困難   | IDE統合とレビューで部分的に対応可能です    |
| コード移動・再配置   | 依存関係の把握・AST理解が不完全  | 構造解析ツールとの併用が効果的です         |
| テスト生成           | 仕様理解・網羅性判断の限界       | テスト設計テンプレートと人間レビュー必須   |
| 実行時デバッグ       | 環境連携・動的情報取得の制限     | ログ解析・外部ツール連携で補完が必要です   |

---

## 4. AIを使いこなすためのプロンプト設計のコツ

### 4.0 cursorでのプロンプト設計の基礎

- **ruleによる基本設定**
  - cursorでは**基本設定** > **Cursor Settings** > **rules**でルールを設定できます
  - 言語設定、コーディング規約、出力フォーマットなどの一般的な指示をruleとして事前に設定可能です
  - 一度設定したruleは以降の会話で継続的に適用されます

- **ruleの活用メリット**
  - 毎回同じ指示を繰り返す必要がなく、効率的なプロンプト設計が可能です
  - プロジェクト全体で一貫した基準を維持できます
  - チーム内で共通のruleを共有することで、AIの出力の品質を統一できます


### 4.1 基本原則：明確さと具体性

- **目的と背景を最初に提示する**
  - 「〜のためのコードが必要です」と目的を明確にします。
  - 「現在のプロジェクトでは〜の技術スタックを使用しています」と背景情報を添えます。

- **出力形式を明示する**
  - 「以下の形式でレスポンスしてください：」と明示的に指定します。
  - コード、説明、コメント量などの希望を具体的に伝えます。

- **制約条件を列挙する**
  - 「ES6構文のみを使用すること」「外部ライブラリは使用しないこと」など明確な制約を設けます。
  - パフォーマンス要件やブラウザ互換性など、非機能要件も明示します。

### 4.2 コンテキスト提供のテクニック

- **既存コードの断片を提供する**
  - 「以下のコードに〜の機能を追加してください」と具体的な開始点を示します。
  - 「このプロジェクトでは以下の命名規則を使用しています」とスタイルガイドを共有します。

- **段階的な指示出しを心がける**
  - 複雑なタスクは「まず〜を行い、次に〜」と段階に分けて指示します。
  - 「まずは基本実装を示し、その後エラー処理を追加してください」など優先順位を付けます。

- **例示を活用する**
  - 「以下のような出力を期待しています：」と具体例を示します。
  - 入出力の例、APIレスポンス例などを提供するとより正確な結果が得られます。

### 4.3 言語モデル別の最適化手法

- **ChatGPT向け**
  - 対話的なプロンプト設計が効果的です。
  - 「前の回答をもう少し詳しく」など、継続的な修正指示に対応します。

- **Claude向け**
  - ルールと論理的整合性を重視したプロンプトに反応が良いです。
  - 「以下の条件を全て満たすコードを書いてください」とリスト形式で指示します。

- **GitHub Copilot向け**
  - コメントによる誘導が効果的です。
  - `// 以下のような関数を実装：` の形でコメント先行型の指示を出します。

### 4.4 実践的なプロンプトパターン

| 目的                 | プロンプトパターン                                           | 効果                                   |
| -------------------- | ------------------------------------------------------------ | -------------------------------------- |
| バグ修正             | 「このコードには〜の問題があります。原因と修正方法を示してください」 | 分析と解決策を同時に得られます         |
| リファクタリング     | 「このコードを可読性と保守性を高めるようリファクタリングしてください」 | 構造改善の提案が得られます             |
| 拡張実装             | 「既存コード〜に〜の機能を追加してください。既存の設計パターンに従ってください」 | 一貫性のある拡張が可能です             |
| パフォーマンス最適化 | 「このコードの実行速度を改善するため、ボトルネックを特定し最適化してください」 | 具体的な最適化提案が得られます         |
| テスト生成           | 「以下の関数に対するユニットテストを、境界値と異常系を含めて作成してください」 | 網羅的なテストケースが得られます       |
| ドキュメント作成     | 「以下のコードに対する技術文書を、使用例と注意点を含めて作成してください」 | 説明的なドキュメントが生成されます     |

---

## 5. AIツールとモデルの選び方・使い分け

### ツールの用途に応じた選定

| ツール         | 特徴                            | 適した用途                         |
| -------------- | ------------------------------- | ---------------------------------- |
| ChatGPT        | 汎用的、対話・要件定義に強い    | 課題分析、プロンプト調整、学習用   |
| Cursor         | IDE統合型、コード補完・修正向き | 実装中の生成・修正・ナビゲーション |
| GitHub Copilot | 自動補完が自然、VSCode向け      | 定型的な補完、ルーチン作成         |

### Cursorに組み込まれているAIエンジンの個性と使い分けの重要性

Cursorは複数のAIモデル（ChatGPT、Claude、Geminiなど）を切り替えて利用できる特徴があります。  これらのモデルはそれぞれ「ルール遵守の度合い」や「創造性」「説明の丁寧さ」などに違いがあり、いわば"キャラクター"を持っています。

#### モデルごとの特性と使い分け

- **ChatGPT**  
  柔軟で創造的、自然言語での説明が丁寧。  
  → アイデア出しや自然言語での解説が欲しい場合に適しています。

- **Claude**  
  ルール遵守に厳格で論理的、堅実な出力を得意とする。  
  → 厳密なコーディング規約やセキュリティ要件を守る必要がある場合に向いています。
  しかし,claude-3.7-sonnetはcursorで設定したルールを最初の数回無視することがあります。これは毎回指摘すれば治ります。
  
- **Gemini**  
  バランス型で多言語対応に強い。  
  → 多様な言語や幅広い用途に対応したい場合に有効です。

---

### Claude 3.7 Sonnetの詳細分析

Claude 3.7 Sonnetは、従来モデル（Claude 3.5 Sonnet等）から大幅な進化を遂げた新世代のAIエンジンです。コーディング支援においても、他のモデルと比較して際立った個性と強みを持っています。

#### 主な特徴

- **ハイブリッド推論アーキテクチャ**
  - 標準モードと拡張思考モードを切り替え可能。
  - 簡単な質問には迅速に、複雑なタスクには多段階の論理的推論で対応可能。

- **拡張思考モード**
  - 難解な課題に対して思考予算を設定し、深い推論を実行。
  - 推論過程の可視化により透明性と信頼性が向上。

- **コーディング能力の大幅強化**
  - SWE-Bench Verified などでトップクラスの性能。
  - Claude Code による GitHub 連携やリポジトリ内操作が可能。

- **大規模文脈対応**
  - 128Kトークンの長文コンテキストに対応。

- **Artifactsによるコードプレビュー**
  - MermaidやSVGで図解生成、コードの視覚化が可能。

#### 他モデルとの比較

| モデル名          | 特徴・キャラクター                               | 向いている用途                               |
| ----------------- | ------------------------------------------------ | -------------------------------------------- |
| Claude 3.7 Sonnet | 深い推論・透明性・高度なコーディング支援・安全性 | 複雑な設計、レビュー、長大コード対応         |
| ChatGPT           | 柔軟・創造的・説明が丁寧                         | 要件整理、自然言語での会話、プロトタイプ生成 |
| Claude 3.5 Sonnet | 標準的な応答性能                                 | 日常的なコーディング、短期的な修正作業       |
| Gemini            | バランス型、多言語対応                           | 多様な環境・タスクへの対応                   |

---

## 6. 人間とAIの役割分担の設計

AIは「生成」や「補完」には強い一方で、「設計判断」や「仕様理解」には限界があります。 以下のように役割を明確に分けることで、効率と品質の両立が可能になります。

| タスク                     | AIに任せる          | 人間が確認・判断すべき  |
| -------------------------- | ------------------- | ----------------------- |
| 新規コードのスケルトン生成 | ◎                   | △（レビューが必要）     |
| バグ修正・リファクタリング | △（案を出せる）     | ◎（意図と副作用の理解） |
| テストデータ設計           | △（生成可能）       | ◎（観点と網羅性の設計） |
| エラー対応                 | △（ヒントは出せる） | ◎（環境と文脈の把握）   |

---

## 7. 活用におけるリスクと注意点

生成AIを現場で使いこなすには、リスクを理解し、適切に対策する必要があります。

### 主なリスク

- ❗ **誤生成の可能性**  
  型やロジックの不整合、未検証の処理が混入するリスクがあります。

- 🛑 **ブラックボックス依存**  
  出力されたコードの意図を理解しないまま使うと、バグや技術的負債に繋がります。

- 🔐 **セキュリティ上の懸念**  
  脆弱性を含むコードや、情報漏洩の恐れのあるやり取りが発生することがあります。

- 🧠 **設計放棄の危険性**  
  人間が設計判断を怠り、AIに丸投げすることでシステムの一貫性が失われる場合があります。

### 実践的な対策

- コードレビューは必ず人間が行う。
- セキュリティスキャン、Linter、テストを自動化して組み込む。
- チームルールやコーディング規約との整合性を常にチェックする。

---

## 8. 継続的な対話と学習の重要性

生成AIは「1回の指示で完璧な結果を出す」ものではありません。  
**対話を重ねること**で、出力の精度と信頼性が高まります。

### 継続的なやり取りが生むメリット

- 意図が明確化され、曖昧な要求が減る。
- AIの応答パターンを把握しやすくなる。
- 開発者側の思考整理にもつながる。

### 比較・選択・統合のスキルを持つ

生成AIは同じ指示に対しても毎回異なる出力を返します。  
「複数出力を比較・統合する力」も、開発者に求められるスキルのひとつです。

#### 例：

- 3通りの生成パターンから、最も読みやすく、実装に適したものを選ぶ。
- 複数出力の良い点を合成する。
- チームレビューで最適解を決定する。

---

## 9. 今後の展望：生成AIはどこまで進化するか？

### 期待される進化

- **構造把握能力の向上**  
  ASTや依存構造を正確に捉え、より意味的に正しいコード生成が可能になる。

- **実行環境との統合**  
  IDEやブラウザと密に連携し、実行ログや例外スタックを直接活用することで、AIによる自動修正や再試行が行えるようになります。

- **プロンプト支援ツールの発展**  
  ユーザーの曖昧な指示を構造化し、AIに正しく伝える「プロンプト中間層」が整備されます。

- **マルチエージェント連携**  
  複数のAIが役割分担し、コード生成・テスト・デバッグを分業でこなす未来が見えています。

---

## 10. まとめ：効率的に作業するヒント

- ✅ プロンプトは"具体的・明確に"書く。制約・フォーマット・目的をセットで提示する。
- ✅ タスクを細かく分割して、段階的にAIに指示する。
- ✅ 出力結果を複数生成し、比較・統合する習慣を持つ。
- ✅ チーム内の規約、セキュリティ方針との整合性を担保する。
- ✅ 対話を重ねて、AIとの相互理解を深める。
- ✅ ツールやエンジン（GPT-4, Claude, Geminiなど）を適材適所で使い分ける。

---

## おわりに

生成AIは「万能なエンジニア」ではありません。 しかし、「文脈を読み、言語を扱う能力」に長けた強力な補助者です。その出力には誤りや未検証の部分もありますが、得意な領域に集中させ、人間が設計と意思決定を担えば、 ソフトウェア開発の生産性と保守性は飛躍的に向上します。

AIを"相棒"として使いこなすには、AIの特性を理解し、開発の中に「対話の時間」を組み込むことが大切でしょう。

---
